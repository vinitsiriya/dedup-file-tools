
# Generic CLI and Config Design Pattern

This document describes a generic design pattern for CLI parsing and configuration management in Python-based tools.


## CLI Parsing Pattern

- Use Python's `argparse` module to build the CLI.
- Implement each command as a subparser, with its own required and optional arguments.
- Map each subcommand to a dedicated handler function.
- The main entry point parses arguments and dispatches to the appropriate handler based on the selected subcommand.
- Help and usage information is automatically generated by `argparse` for all commands and options.


## Config File Integration

- Support a `--config` option to allow users to specify a YAML (or JSON) configuration file.
- Load the config file and merge its values with CLI arguments.
- CLI arguments always take precedence over config file values, ensuring explicit user intent is respected.
- This pattern allows for both reproducible automation (via config files) and flexible ad-hoc overrides (via CLI).


## Logging

- Initialize logging based on CLI arguments (e.g., `--log-level`, `--output-dir`).
- Ensure logs are written to the correct location for each job or run.


## Handler Dispatch

- Each subcommand is handled by a dedicated function.
- The main function is responsible for parsing arguments, loading config, setting up logging, and dispatching to the correct handler.
- This separation of concerns keeps CLI parsing, config management, and business logic cleanly decoupled.



## Example Flow

1. User runs a command, e.g.:
   ```
   python -m my_tool.main do-something --output-dir results/ --config config.yaml
   ```
2. `argparse` parses the CLI arguments and identifies the subcommand.
3. If `--config` is provided, the YAML config is loaded and merged.
4. Logging is set up for the specified output directory.
5. The appropriate handler function is called with the parsed arguments.


## Code Samples

### CLI Parsing and Config Merge
```python
import argparse

def main(argv=None):
    parser = argparse.ArgumentParser()
    # ... add subparsers and arguments ...
    args = parser.parse_args(argv)
    if getattr(args, 'config', None):
        config_dict = load_yaml_config(args.config)
        args = merge_config_with_args(args, config_dict, parser)
    # ... dispatch to handler ...
```

### Handler Dispatch
```python
if args.command == 'do-something':
    handle_do_something(args.output_dir, args.input_file)
# ... other commands ...
```

### Handler Function
```python
def handle_do_something(output_dir, input_file):
    # ... perform the main logic ...
    logging.info(f'Operation complete for {input_file}')
```


---

This pattern ensures a robust, user-friendly, and maintainable CLI and configuration experience for Python command-line tools.
